# -*- coding: utf-8 -*-import mathfrom misc import Colorclass Point:    def __init__(self, x, y, z):        self.x = x        self.y = y        self.z = z    def __repr__(self):        return 'Point(%s,%s,%s)' % (self.x, self.y, self.z)    def __sub__(self, point):        return Vector(self.x-point.x, self.y-point.y, self.z-point.z)class Vector:    def __init__(self, x, y, z):        self.x = x        self.y = y        self.z = z    def __repr__(self):        return 'Vector(%s,%s,%s)' % (self.x, self.y, self.z)    # http://www.mathe-online.at/materialien/ursl/files/Rechnen.html    def __add__(self, vector):        return Vector(self.x+vector.x, self.y+vector.y, self.z+vector.z)    # http://www.lernort-mint.de/Mathematik/Vektoren/vektoren_division.html    def __div__(self, n):        return Vector(self.x/n, self.y/n, self.z/n)    def dot(self, v):        return self.x*v.x + self.y*v.y + self.z*v.z    def length(self):        return math.sqrt(self.x**2 + self.y**2 + self.z**2)    # http://massmatics.de/merkzettel/index.php#!339:Vektoren_normieren    def normalized(self):        return Vector(self.x/self.length(), self.y/self.length(), self.z/self.length())    def scale(self, t):        return Vector(self.x*t, self.y*t, self.z*t)    # https://www.youtube.com/watch?v=UzWnp97GN9g    def cross(self, v):        return Vector(            self.y*v.z - self.z*v.y,            self.z*v.x - self.x*v.z,            self.x*v.y - self.y*v.x,        )class Ray:    def __init__(self, origin, direction):        self.origin = origin # point        self.direction = direction.normalized() # vector    def __repr__(self):        return 'Ray(%s,%s)' % (repr(self.origin), repr(self.direction))    def pointAtParameter(self, t):        return self.origin + self.direction.scale(t)class Camera:    def __init__(self, e, c, up, fov, image_width, image_height):        self.e = e      # camera point (eye)        self.c = c      # center point (center)        self.up = up    # camera up vector        self.fov = fov  # fieldofview (brennweite?)        self.f = (self.c-self.e) / (self.c-self.e).length()        self.s = (self.f.cross(self.up)) / self.f.cross(self.up).length()        self.u = self.s.cross(self.f)        self.alpha = self.fov / 2        self.height = 2 * math.tan(math.radians(self.alpha))        self.width = (image_width / image_height) * self.height        self.pixel_height = self.height / (image_height-1)        self.pixel_width = self.width / (image_width-1)    def __repr__(self):        return '''Camera(\n            e=%s,            c=%s,            up=%s,            fov=%s,            width=%s,            height=%s        )''' % (self.e, self.c, self.up, self.fov, self.width, self.height)class Plane:    def __init__(self, point, normal):        self.point = point # point        self.normal = normal.normalized() # vector    def __repr__(self):        return 'Plane(%s,%s)' % (repr(self.point), repr(self.normal))    def intersectionParameter(self, ray):        op = ray.origin - self.point        a = op.dot(self.normal)        b = ray.direction.dot(self.normal)        if b:            return -a/b        else:            return None    def normalAt(self, p):        return self.normal    def colorAt(self, ray):        return Color(            125,            125,            125,        )class Sphere:    def __init__(self, center, radius, color):        self.center = center # point self.radius = radius # scalar        self.radius = radius        self.color = color    def __repr__(self):        return 'Sphere(%s,%s)' % (repr(self.center), self.radius)    def intersectionParameter(self, ray):        co = self.center - ray.origin        v = co.dot(ray.direction)        discriminant = v*v - co.dot(co) + self.radius*self.radius        if discriminant < 0:            return None        else:            return v - math.sqrt(discriminant)    def normalAt(self, p):        return (p - self.center).normalized()    def colorAt(self, ray):        return self.colorclass Triangle:    def __init__(self, a, b, c, color):        self.a = a # point        self.b = b # point        self.c = c # point        self.color = color        self.u = self.b - self.a # direction vector        self.v = self.c - self.a # direction vector    def __repr__(self):        return 'Triangle(%s,%s,%s)' % (repr(self.a), repr(self.b), repr(self.c))    def intersectionParameter(self, ray):        w = ray.origin - self.a        dv = ray.direction.cross(self.v)        dvu = dv.dot(self.u)        if dvu == 0.0:            return None        wu = w.cross(self.u)        r = dv.dot(w) / dvu        s = wu.dot(ray.direction) / dvu        if 0<=r and r<=1 and 0<=s and s<=1 and r+s <=1:            return wu.dot(self.v) / dvu        else:            return None    def normalAt(self, p):        return self.u.cross(self.v).normalized()    def colorAt(self, ray):        return self.color